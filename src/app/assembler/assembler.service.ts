import { Injectable } from '@angular/core';
import { OPCodes, REGEX, RegexLabel, RegexNum } from '../shared/constants';

export type AssembleCode = number[];
export type AssembleMapping = Record<string, number>;
export type AssembleLabels = Record<string, number>;
@Injectable({
  providedIn: 'root',
})
export class AssemblerService {
  go(input: string) {
    // Regex group indexes for operands
    const op1_group = 3;
    const op2_group = 7;

    // Contains the program code & data generated by the assembler
    const code: AssembleCode = [];
    // Contains the mapping from instructions to assembler line
    const mapping: AssembleMapping = {};
    // Hash map of label used to replace the labels after the assembler generated the code
    const labels: AssembleLabels = {};
    // Hash of uppercase labels used to detect duplicates
    const normalizedLabels: AssembleLabels = {};

    // Split text into code lines
    const lines = input.split('\n');

    for (let i = 0, l = lines.length; i < l; i++) {
      try {
        const match = REGEX.exec(lines[i]);
        if (match[1] !== undefined || match[2] !== undefined) {
          if (match[1] !== undefined) {
            this.addLabel(match[1], normalizedLabels, labels, code);
          }

          if (match[2] !== undefined) {
            const instr = match[2].toUpperCase();
            let p1, p2, opCode;

            // Add mapping instr pos to line number
            // Don't do it for DB as this is not a real instruction
            if (instr !== 'DB') {
              mapping[code.length] = i;
            }

            switch (instr) {
              case 'DB':
                p1 = this.getValue(match[op1_group]);
                this.checkOneOperand(instr, p1);

                if (p1.type === 'number') {
                  code.push(p1.value);
                } else if (p1.type === 'numbers') {
                  for (let j = 0, k = p1.value.length; j < k; j++) {
                    code.push(p1.value[j]);
                  }
                } else {
                  throw new Error('DB does not support this operand');
                }

                break;
              case 'NOP':
                this.checkNoExtraArg('NOP', match[op1_group]);
                code.push(OPCodes.NOPE);
                break;
              case 'HLT':
                this.checkNoExtraArg('HLT', match[op1_group]);
                code.push(OPCodes.NONE);
                break;

              case 'MOV':
                p1 = this.getValue(match[op1_group]);
                p2 = this.getValue(match[op2_group]);
                this.checkTwoOperands(instr, p1, p2);

                if (p1.type === 'register' && p2.type === 'register') {
                  opCode = OPCodes.MOV_REG_TO_REG;
                } else if (p1.type === 'register' && p2.type === 'address') {
                  opCode = OPCodes.MOV_ADDRESS_TO_REG;
                } else if (p1.type === 'register' && p2.type === 'regaddress') {
                  opCode = OPCodes.MOV_REGADDRESS_TO_REG;
                } else if (p1.type === 'address' && p2.type === 'register') {
                  opCode = OPCodes.MOV_REG_TO_ADDRESS;
                } else if (p1.type === 'regaddress' && p2.type === 'register') {
                  opCode = OPCodes.MOV_REG_TO_REGADDRESS;
                } else if (p1.type === 'register' && p2.type === 'number') {
                  opCode = OPCodes.MOV_NUMBER_TO_REG;
                } else if (p1.type === 'address' && p2.type === 'number') {
                  opCode = OPCodes.MOV_NUMBER_TO_ADDRESS;
                } else if (p1.type === 'regaddress' && p2.type === 'number') {
                  opCode = OPCodes.MOV_NUMBER_TO_REGADDRESS;
                } else {
                  throw new Error('MOV does not support this operands');
                }

                code.push(opCode, p1.value, p2.value);
                break;
              case 'ADD':
                p1 = this.getValue(match[op1_group]);
                p2 = this.getValue(match[op2_group]);
                this.checkTwoOperands(instr, p1, p2);

                if (p1.type === 'register' && p2.type === 'register') {
                  opCode = OPCodes.ADD_REG_TO_REG;
                } else if (p1.type === 'register' && p2.type === 'regaddress') {
                  opCode = OPCodes.ADD_REGADDRESS_TO_REG;
                } else if (p1.type === 'register' && p2.type === 'address') {
                  opCode = OPCodes.ADD_ADDRESS_TO_REG;
                } else if (p1.type === 'register' && p2.type === 'number') {
                  opCode = OPCodes.ADD_NUMBER_TO_REG;
                } else {
                  throw new Error('ADD does not support this operands');
                }
                code.push(opCode, p1.value, p2.value);
                break;
              case 'SUB':
                p1 = this.getValue(match[op1_group]);
                p2 = this.getValue(match[op2_group]);
                this.checkTwoOperands(instr, p1, p2);

                if (p1.type === 'register' && p2.type === 'register') {
                  opCode = OPCodes.SUB_REG_FROM_REG;
                } else if (p1.type === 'register' && p2.type === 'regaddress') {
                  opCode = OPCodes.SUB_REGADDRESS_FROM_REG;
                } else if (p1.type === 'register' && p2.type === 'address') {
                  opCode = OPCodes.SUB_ADDRESS_FROM_REG;
                } else if (p1.type === 'register' && p2.type === 'number') {
                  opCode = OPCodes.SUB_NUMBER_FROM_REG;
                } else {
                  throw new Error('SUB does not support this operands');
                }
                code.push(opCode, p1.value, p2.value);
                break;
              case 'INC':
                p1 = this.getValue(match[op1_group]);
                this.checkOneOperand(instr, p1);
                this.checkNoExtraArg(instr, match[op2_group]);

                if (p1.type === 'register') {
                  opCode = OPCodes.INC_REG;
                } else {
                  throw new Error('INC does not support this operand');
                }
                code.push(opCode, p1.value);
                break;
              case 'DEC':
                p1 = this.getValue(match[op1_group]);
                this.checkOneOperand(instr, p1);
                this.checkNoExtraArg(instr, match[op2_group]);

                if (p1.type === 'register') {
                  opCode = OPCodes.DEC_REG;
                } else {
                  throw new Error('DEC does not support this operand');
                }

                code.push(opCode, p1.value);

                break;
              case 'CMP':
                p1 = this.getValue(match[op1_group]);
                p2 = this.getValue(match[op2_group]);
                this.checkTwoOperands(instr, p1, p2);

                if (p1.type === 'register' && p2.type === 'register') {
                  opCode = OPCodes.CMP_REG_WITH_REG;
                } else if (p1.type === 'register' && p2.type === 'regaddress') {
                  opCode = OPCodes.CMP_REGADDRESS_WITH_REG;
                } else if (p1.type === 'register' && p2.type === 'address') {
                  opCode = OPCodes.CMP_ADDRESS_WITH_REG;
                } else if (p1.type === 'register' && p2.type === 'number') {
                  opCode = OPCodes.CMP_NUMBER_WITH_REG;
                } else {
                  throw new Error('CMP does not support this operands');
                }
                code.push(opCode, p1.value, p2.value);
                break;
              case 'JMP':
                p1 = this.getValue(match[op1_group]);
                this.checkOneOperand(instr, p1);
                this.checkNoExtraArg(instr, match[op2_group]);

                if (p1.type === 'register') {
                  opCode = OPCodes.JMP_REGADDRESS;
                } else if (p1.type === 'number') {
                  opCode = OPCodes.JMP_ADDRESS;
                } else {
                  throw new Error('JMP does not support this operands');
                }

                code.push(opCode, p1.value);
                break;
              case 'JC':
              case 'JB':
              case 'JNAE':
                p1 = this.getValue(match[op1_group]);
                this.checkOneOperand(instr, p1);
                this.checkNoExtraArg(instr, match[op2_group]);

                if (p1.type === 'register') {
                  opCode = OPCodes.JC_REGADDRESS;
                } else if (p1.type === 'number') {
                  opCode = OPCodes.JC_ADDRESS;
                } else {
                  throw new Error(`${instr}  does not support this operand`);
                }

                code.push(opCode, p1.value);
                break;
              case 'JNC':
              case 'JNB':
              case 'JAE':
                p1 = this.getValue(match[op1_group]);
                this.checkOneOperand(instr, p1);
                this.checkNoExtraArg(instr, match[op2_group]);

                if (p1.type === 'register') {
                  opCode = OPCodes.JNC_REGADDRESS;
                } else if (p1.type === 'number') {
                  opCode = OPCodes.JNC_ADDRESS;
                } else {
                  throw new Error(`${instr}  does not support this operand`);
                }

                code.push(opCode, p1.value);
                break;
              case 'JZ':
              case 'JE':
                p1 = this.getValue(match[op1_group]);
                this.checkOneOperand(instr, p1);
                this.checkNoExtraArg(instr, match[op2_group]);

                if (p1.type === 'register') {
                  opCode = OPCodes.JZ_REGADDRESS;
                } else if (p1.type === 'number') {
                  opCode = OPCodes.JZ_ADDRESS;
                } else {
                  throw new Error(`${instr} does not support this operand`);
                }

                code.push(opCode, p1.value);
                break;
              case 'JNZ':
              case 'JNE':
                p1 = this.getValue(match[op1_group]);
                this.checkOneOperand(instr, p1);
                this.checkNoExtraArg(instr, match[op2_group]);

                if (p1.type === 'register') {
                  opCode = OPCodes.JNZ_REGADDRESS;
                } else if (p1.type === 'number') {
                  opCode = OPCodes.JNZ_ADDRESS;
                } else {
                  throw new Error(`${instr} does not support this operand`);
                }

                code.push(opCode, p1.value);
                break;
              case 'JA':
              case 'JNBE':
                p1 = this.getValue(match[op1_group]);
                this.checkOneOperand(instr, p1);
                this.checkNoExtraArg(instr, match[op2_group]);

                if (p1.type === 'register') {
                  opCode = OPCodes.JA_REGADDRESS;
                } else if (p1.type === 'number') {
                  opCode = OPCodes.JA_ADDRESS;
                } else {
                  throw new Error(`${instr} does not support this operand`);
                }

                code.push(opCode, p1.value);
                break;
              case 'JNA':
              case 'JBE':
                p1 = this.getValue(match[op1_group]);
                this.checkOneOperand(instr, p1);
                this.checkNoExtraArg(instr, match[op2_group]);

                if (p1.type === 'register') {
                  opCode = OPCodes.JNA_REGADDRESS;
                } else if (p1.type === 'number') {
                  opCode = OPCodes.JNA_ADDRESS;
                } else {
                  throw new Error(`${instr} does not support this operand`);
                }

                code.push(opCode, p1.value);
                break;
              case 'PUSH':
                p1 = this.getValue(match[op1_group]);
                this.checkOneOperand(instr, p1);
                this.checkNoExtraArg(instr, match[op2_group]);

                if (p1.type === 'register') {
                  opCode = OPCodes.PUSH_REG;
                } else if (p1.type === 'regaddress') {
                  opCode = OPCodes.PUSH_REGADDRESS;
                } else if (p1.type === 'address') {
                  opCode = OPCodes.PUSH_ADDRESS;
                } else if (p1.type === 'number') {
                  opCode = OPCodes.PUSH_NUMBER;
                } else {
                  throw new Error('PUSH does not support this operand');
                }

                code.push(opCode, p1.value);
                break;
              case 'POP':
                p1 = this.getValue(match[op1_group]);
                this.checkNoExtraArg(instr, match[op2_group]);
                this.checkOneOperand(instr, p1);

                if (p1.type === 'register') {
                  opCode = OPCodes.POP_REG;
                } else {
                  throw new Error('POP does not support this operand');
                }

                code.push(opCode, p1.value);
                break;
              case 'CALL':
                p1 = this.getValue(match[op1_group]);
                this.checkNoExtraArg(instr, match[op2_group]);
                this.checkOneOperand(instr, p1);

                if (p1.type === 'register') {
                  opCode = OPCodes.CALL_REGADDRESS;
                } else if (p1.type === 'number') {
                  opCode = OPCodes.CALL_ADDRESS;
                } else {
                  throw new Error('CALL does not support this operand');
                }

                code.push(opCode, p1.value);
                break;
              case 'RET':
                this.checkNoExtraArg(instr, match[op1_group]);

                opCode = OPCodes.RET;

                code.push(opCode);
                break;

              case 'MUL':
                p1 = this.getValue(match[op1_group]);
                this.checkOneOperand(instr, p1);
                this.checkNoExtraArg(instr, match[op2_group]);

                if (p1.type === 'register') {
                  opCode = OPCodes.MUL_REG;
                } else if (p1.type === 'regaddress') {
                  opCode = OPCodes.MUL_REGADDRESS;
                } else if (p1.type === 'address') {
                  opCode = OPCodes.MUL_ADDRESS;
                } else if (p1.type === 'number') {
                  opCode = OPCodes.MUL_NUMBER;
                } else {
                  throw new Error('MUL does not support this operand');
                }

                code.push(opCode, p1.value);
                break;
              case 'DIV':
                p1 = this.getValue(match[op1_group]);
                this.checkOneOperand(instr, p1);
                this.checkNoExtraArg(instr, match[op2_group]);

                if (p1.type === 'register') {
                  opCode = OPCodes.DIV_REG;
                } else if (p1.type === 'regaddress') {
                  opCode = OPCodes.DIV_REGADDRESS;
                } else if (p1.type === 'address') {
                  opCode = OPCodes.DIV_ADDRESS;
                } else if (p1.type === 'number') {
                  opCode = OPCodes.DIV_NUMBER;
                } else {
                  throw new Error('DIV does not support this operand');
                }

                code.push(opCode, p1.value);
                break;
              case 'AND':
                p1 = this.getValue(match[op1_group]);
                p2 = this.getValue(match[op2_group]);
                this.checkTwoOperands(instr, p1, p2);

                if (p1.type === 'register' && p2.type === 'register') {
                  opCode = OPCodes.AND_REG_WITH_REG;
                } else if (p1.type === 'register' && p2.type === 'regaddress') {
                  opCode = OPCodes.AND_REGADDRESS_WITH_REG;
                } else if (p1.type === 'register' && p2.type === 'address') {
                  opCode = OPCodes.AND_ADDRESS_WITH_REG;
                } else if (p1.type === 'register' && p2.type === 'number') {
                  opCode = OPCodes.AND_NUMBER_WITH_REG;
                } else {
                  throw new Error('AND does not support this operands');
                }

                code.push(opCode, p1.value, p2.value);
                break;
              case 'OR':
                p1 = this.getValue(match[op1_group]);
                p2 = this.getValue(match[op2_group]);
                this.checkTwoOperands(instr, p1, p2);

                if (p1.type === 'register' && p2.type === 'register') {
                  opCode = OPCodes.OR_REG_WITH_REG;
                } else if (p1.type === 'register' && p2.type === 'regaddress') {
                  opCode = OPCodes.OR_REGADDRESS_WITH_REG;
                } else if (p1.type === 'register' && p2.type === 'address') {
                  opCode = OPCodes.OR_ADDRESS_WITH_REG;
                } else if (p1.type === 'register' && p2.type === 'number') {
                  opCode = OPCodes.OR_NUMBER_WITH_REG;
                } else {
                  throw new Error('OR does not support this operands');
                }
                code.push(opCode, p1.value, p2.value);
                break;
              case 'XOR':
                p1 = this.getValue(match[op1_group]);
                p2 = this.getValue(match[op2_group]);
                this.checkTwoOperands(instr, p1, p2);

                if (p1.type === 'register' && p2.type === 'register') {
                  opCode = OPCodes.XOR_REG_WITH_REG;
                } else if (p1.type === 'register' && p2.type === 'regaddress') {
                  opCode = OPCodes.XOR_REGADDRESS_WITH_REG;
                } else if (p1.type === 'register' && p2.type === 'address') {
                  opCode = OPCodes.XOR_ADDRESS_WITH_REG;
                } else if (p1.type === 'register' && p2.type === 'number') {
                  opCode = OPCodes.XOR_NUMBER_WITH_REG;
                } else {
                  throw new Error('XOR does not support this operands');
                }
                code.push(opCode, p1.value, p2.value);
                break;
              case 'NOT':
                p1 = this.getValue(match[op1_group]);
                this.checkOneOperand(instr, p1);
                this.checkNoExtraArg(instr, match[op2_group]);

                if (p1.type === 'register') {
                  opCode = OPCodes.NOT_REG;
                } else {
                  throw new Error('NOT does not support this operand');
                }

                code.push(opCode, p1.value);
                break;
              case 'SHL':
              case 'SAL':
                p1 = this.getValue(match[op1_group]);
                p2 = this.getValue(match[op2_group]);
                this.checkTwoOperands(instr, p1, p2);

                if (p1.type === 'register' && p2.type === 'register') {
                  opCode = OPCodes.SHL_REG_WITH_REG;
                } else if (p1.type === 'register' && p2.type === 'regaddress') {
                  opCode = OPCodes.SHL_REGADDRESS_WITH_REG;
                } else if (p1.type === 'register' && p2.type === 'address') {
                  opCode = OPCodes.SHL_ADDRESS_WITH_REG;
                } else if (p1.type === 'register' && p2.type === 'number') {
                  opCode = OPCodes.SHL_NUMBER_WITH_REG;
                } else {
                  throw new Error(`${instr} does not support this operands`);
                }
                code.push(opCode, p1.value, p2.value);
                break;
              case 'SHR':
              case 'SAR':
                p1 = this.getValue(match[op1_group]);
                p2 = this.getValue(match[op2_group]);
                this.checkTwoOperands(instr, p1, p2);

                if (p1.type === 'register' && p2.type === 'register') {
                  opCode = OPCodes.SHR_REG_WITH_REG;
                } else if (p1.type === 'register' && p2.type === 'regaddress') {
                  opCode = OPCodes.SHR_REGADDRESS_WITH_REG;
                } else if (p1.type === 'register' && p2.type === 'address') {
                  opCode = OPCodes.SHR_ADDRESS_WITH_REG;
                } else if (p1.type === 'register' && p2.type === 'number') {
                  opCode = OPCodes.SHR_NUMBER_WITH_REG;
                } else {
                  throw new Error(`${instr} does not support this operands`);
                }
                break;
              default:
                throw new Error(`Invalid instruction: ${match[2]}`);
            }
          }
        } else {
          // Check if line starts with a comment otherwise the line contains an error and can not be parsed
          const line = lines[i].trim();
          if (line !== '' && line.slice(0, 1) !== ';') {
            throw new Error('Syntax error');
          }
        }
      } catch (error) {
        throw { error, line: i };
      }
    }

    // Replace label
    for (let i = 0, l = code.length; i < l; i++) {
      if (typeof code[i] !== 'number') {
        if (code[i] in labels) {
          code[i] = labels[code[i]];
        } else {
          throw { error: 'Undefined label: ' + code[i] };
        }
      }
    }

    return { code, mapping, labels };
  }

  private parseNumber(input: string) {
    if (input.slice(0, 2) === '0x') {
      return parseInt(input.slice(2), 16);
    }

    if (input.slice(0, 2) === '0o') {
      return parseInt(input.slice(2), 8);
    }

    if (input.slice(input.length - 1) === 'b') {
      return parseInt(input.slice(0, input.length - 1), 2);
    }

    if (input.slice(input.length - 1) === 'd') {
      return parseInt(input.slice(0, input.length - 1), 10);
    }

    if (RegexNum.exec(input)) {
      return parseInt(input, 10);
    }

    throw new Error('Invalid number format');
  }

  /**
   * Allowed formats: 200, 200d, 0xA4, 0o48, 101b
   * Allowed registers: A, B, C, D, SP
   * @param input
   * @returns
   */
  private parseRegister(input: string) {
    input = input.toUpperCase();

    if (input === 'A') {
      return 0;
    }

    if (input === 'B') {
      return 1;
    }

    if (input === 'C') {
      return 2;
    }

    if (input === 'D') {
      return 3;
    }

    if (input === 'SP') {
      return 4;
    }
    return undefined;
  }

  private parseOffsetAddressing(input: string): number | undefined {
    input = input.toUpperCase();
    let m = 0;
    let base = 0;

    if (input[0] === 'A') {
      base = 0;
    } else if (input[0] === 'B') {
      base = 1;
    } else if (input[0] === 'C') {
      base = 2;
    } else if (input[0] === 'D') {
      base = 3;
    } else if (input.slice(0, 2) === 'SP') {
      base = 4;
    } else {
      return undefined;
    }
    let offset_start = 1;
    if (base === 4) {
      offset_start = 2;
    }

    if (input[offset_start] === '-') {
      m = -1;
    } else if (input[offset_start] === '+') {
      m = 1;
    } else {
      return undefined;
    }

    let offset = m * parseInt(input.slice(offset_start + 1), 10);

    if (offset < -16 || offset > 15) {
      throw new Error('offset must be a value between -16...+15');
    }

    if (offset < 0) {
      offset = 32 + offset; // two's complement representation in 5-bit
    }

    return offset * 8 + base; // shift offset 3 bits right and add code for register
  }

  /**
   * Allowed: Register, Label or Number; SP+/-Number is allowed for 'regaddress' type
   * @param input
   * @param typeReg register type
   * @param typeNumber number type
   * @returns
   */
  private parseRegOrNumber(
    input: string,
    typeReg: 'register' | 'regaddress',
    typeNumber: 'number' | 'address'
  ) {
    let register = this.parseRegister(input);

    if (register !== undefined) {
      return { type: typeReg, value: register };
    }

    const label = this.parseLabel(input);
    if (label !== undefined) {
      return { type: typeNumber, value: label };
    }

    if (typeReg === 'regaddress') {
      register = this.parseOffsetAddressing(input);

      if (register !== undefined) {
        return { type: typeReg, value: register };
      }
    }

    const value = this.parseNumber(input);

    if (isNaN(value)) {
      throw new Error(`Not a ${typeNumber}: ${value}`);
    }

    if (value < 0 || value > 255) {
      throw new Error(`${typeNumber} must have a value between 0-255`);
    }

    return { type: typeNumber, value };
  }

  private parseLabel(input: string) {
    return RegexLabel.exec(input) ? input : undefined;
  }

  private checkOneOperand(instr: string, p1: any) {
    if (!p1) {
      throw new Error(`${instr} needs one operand`);
    }
  }

  private checkTwoOperands(instr: string, p1: any, p2: any) {
    if (!p1 || !p2) {
      throw new Error(`${instr} needs one operand`);
    }
  }
  private checkNoExtraArg(instr: string, arg: any) {
    if (arg !== undefined) {
      throw new Error(`${instr}: too many arguments`);
    }
  }
  /**
   * parse operands
   * @param input
   * @returns
   */
  private getValue(input?: string) {
    if (!input) {
      return null;
    }
    switch (input.slice(0, 1)) {
      case '[': // [number] or [register]
        const address = input.slice(1, input.length - 1);
        return this.parseRegOrNumber(address, 'regaddress', 'address');
      case '"': // "String"
        const text = input.slice(1, input.length - 1);
        const chars = [];

        for (let i = 0, l = text.length; i < l; i++) {
          chars.push(text.charCodeAt(i));
        }

        return { type: 'numbers', value: chars };
      case "'": // 'C'
        const character = input.slice(1, input.length - 1);
        if (character.length > 1) {
          throw new Error('Only one character is allowed. Use String instead');
        }

        return { type: 'number', value: character.charCodeAt(0) };
      default:
        // REGISTER, NUMBER or LABEL
        return this.parseRegOrNumber(input, 'register', 'number');
    }
  }
  private addLabel(
    label: string,
    normalizedLabels: AssembleLabels,
    labels: AssembleLabels,
    code: AssembleCode
  ) {
    const upperLabel = label.toUpperCase();
    if (upperLabel in normalizedLabels) {
      throw new Error(`Duplicate label: ${label};`);
    }

    if (
      upperLabel === 'A' ||
      upperLabel === 'B' ||
      upperLabel === 'C' ||
      upperLabel === 'D'
    ) {
      throw new Error(`Label contains keyword: ${upperLabel}`);
    }

    labels[label] = code.length;
  }
}
